import React, { useMemo } from 'react';
import { AIChatbot } from './AIChatbot/AIChatbot';
import { ChatProvider, ChatContext, ChatResponse, ChatbotConfig as AIChatbotConfig } from './AIChatbot/types';
import { ChatService } from './services/ChatService';
import { ChatbotConfig, mergeWithDefaults } from './config';
import { ChatMessage as SDKChatMessage, RAGResponse, TopicContext } from './types';

/**
 * Firebase-based chat provider that uses the ChatService
 */
class FirebaseChatProvider implements ChatProvider {
  name = 'firebase';
  private chatService: ChatService;
  private selectedAgent: string = 'askRex';
  private maxResults: number = 5;
  private streamingThreshold: number = 300;
  private availableAgents: string[] = ['askRex'];

  constructor(chatService: ChatService, config: {
    agentName?: string;
    maxResults?: number;
    streamingThreshold?: number;
    availableAgents?: string[];
  }) {
    this.chatService = chatService;
    this.availableAgents = config.availableAgents || ['askRex'];
    this.selectedAgent = config.agentName || this.availableAgents[0];
    this.maxResults = config.maxResults || 5;
    this.streamingThreshold = config.streamingThreshold || 300;
  }

  switchAgent(agentName: string): void {
    console.log(`üîÑ [Chatbot] switchAgent called with: ${agentName}`);
    console.log(`üîÑ [Chatbot] Available agents:`, this.availableAgents);
    
    // Validate agent is in available agents list
    if (!this.availableAgents.includes(agentName)) {
      console.warn(`‚ùå [Chatbot] Agent "${agentName}" not in available agents list:`, this.availableAgents);
      return;
    }

    this.selectedAgent = agentName;
    console.log(`‚úÖ [Chatbot] Agent switched to: ${agentName}`);
    
    // Save to Firestore (fire-and-forget)
    this.saveAgentPreference(agentName);
  }

  private async saveAgentPreference(agentName: string): Promise<void> {
    try {
      const DEBUG = await this.chatService.getDebugStreamingFlag();
      if (DEBUG) {
        console.log(`üîß [Chatbot] Saving agent preference: ${agentName}`);
      }
      
      await this.chatService.saveChatbotPreferences({ selectedAgent: agentName });
      console.log(`üíæ [Chatbot] Saved agent preference to Firestore: ${agentName}`);
      
      if (DEBUG) {
        console.log(`‚úÖ [Chatbot] Debug: Save complete`);
      }
    } catch (err) {
      console.error('‚ùå [Chatbot] Failed to save agent preference:', err);
    }
  }

  private async saveStreamingThresholdPreference(threshold: number): Promise<void> {
    try {
      const DEBUG = await this.chatService.getDebugStreamingFlag();
      if (DEBUG) {
        console.log(`üîß [Chatbot] Saving streaming threshold: ${threshold}`);
      }
      
      await this.chatService.saveChatbotPreferences({ streamingThreshold: threshold });
      console.log(`üíæ [Chatbot] Saved streaming threshold to Firestore: ${threshold}`);
      
      if (DEBUG) {
        console.log(`‚úÖ [Chatbot] Debug: Save complete`);
      }
    } catch (err) {
      console.error('‚ùå [Chatbot] Failed to save streaming threshold:', err);
    }
  }

  getAvailableAgents(): string[] {
    return this.availableAgents;
  }

  getCurrentAgent(): string {
    return this.selectedAgent;
  }

  setStreamingThreshold(threshold: number): void {
    console.log(`üîÑ [Chatbot] setStreamingThreshold called with: ${threshold}`);
    this.streamingThreshold = threshold;
    console.log(`‚úÖ [Chatbot] Streaming threshold changed to: ${threshold}`);
    this.saveStreamingThresholdPreference(threshold);
  }
  }

  private convertTopicContext(context?: ChatContext): TopicContext | undefined {
    if (!context?.topicContext) return undefined;
    return {
      originalTopic: context.topicContext.originalTopic,
      topicDescription: context.topicContext.topicDescription,
      contextHints: context.topicContext.contextHints,
    };
  }

  private convertMessagesToSDK(messages: ChatMessage[]): SDKChatMessage[] {
    return messages.map(msg => ({
      id: msg.id,
      content: msg.content,
      role: msg.role,
      timestamp: msg.timestamp,
    }));
  }

  private convertRAGResponseToChatResponse(ragResponse: RAGResponse): ChatResponse {
    return {
      answer: ragResponse.answer,
      sources: ragResponse.sources?.map((source) => ({
        id: source.id,
        filename: source.filename,
        path: source.path,
        contentType: source.contentType,
        similarity: source.similarity,
        contributionPercentage: source.contributionPercentage,
        rank: source.rank,
        preview: source.preview,
        isChunk: source.isChunk,
        chunkIndex: source.chunkIndex,
        totalChunks: source.totalChunks,
        parentDocumentId: source.parentDocumentId,
      })) || [],
      searchTime: ragResponse.searchTime || 0,
      totalDocuments: ragResponse.totalDocuments || ragResponse.sources?.length || 0,
      confidence: ragResponse.confidence || 0.8,
      timings: ragResponse.timings,
      tokenUsage: ragResponse.tokenUsage,
      streamingMetrics: ragResponse.streamingMetrics,
    };
  }

  async sendMessage(
    message: string,
    context: ChatContext,
    config?: Partial<AIChatbotConfig>
  ): Promise<ChatResponse> {
    const topicContext = this.convertTopicContext(context);
    const conversationHistory = this.convertMessagesToSDK(context.conversationHistory);

    const ragResponse = await this.chatService.sendMessage(
      message,
      this.maxResults,
      conversationHistory,
      topicContext,
      this.selectedAgent
    );

    return this.convertRAGResponseToChatResponse(ragResponse);
  }

  async streamMessage(
    message: string,
    context: ChatContext,
    onChunk: (chunk: string) => void,
    onComplete?: (response: ChatResponse) => void,
    config?: Partial<AIChatbotConfig>
  ): Promise<void> {
    const topicContext = this.convertTopicContext(context);
    const conversationHistory = this.convertMessagesToSDK(context.conversationHistory);
    
    // Use streaming threshold from config if provided, otherwise use default
    const streamingThreshold = config?.streamingThreshold ?? this.streamingThreshold;
    
    // Save streaming threshold if it changed
    if (config?.streamingThreshold !== undefined && config.streamingThreshold !== this.streamingThreshold) {
      this.streamingThreshold = config.streamingThreshold;
      console.log(`ÔøΩ [Chatbot] Streaming threshold changed to: ${config.streamingThreshold}`);
      this.saveStreamingThresholdPreference(config.streamingThreshold);
    }

    await this.chatService.streamMessage(
      message,
      this.maxResults,
      conversationHistory,
      this.selectedAgent,
      onChunk,
      (ragResponse: RAGResponse) => {
        if (onComplete) {
          const chatResponse = this.convertRAGResponseToChatResponse(ragResponse);
          onComplete(chatResponse);
        }
      },
      topicContext,
      streamingThreshold
    );
  }
}

// Import ChatMessage from AIChatbot types for internal use
type ChatMessage = import('./AIChatbot/types').ChatMessage;

/**
 * Chatbot - Black box chatbot component with Firebase backend
 * 
 * This is a complete, batteries-included chatbot component that requires
 * only a Firebase app instance to work. It wraps the AIChatbot UI component
 * with a Firebase-based provider and service layer.
 * 
 * @example
 * ```tsx
 * import { initializeApp } from 'firebase/app';
 * import { Chatbot } from 'shockproof-components';
 * 
 * const firebaseApp = initializeApp({ ... });
 * 
 * function MyApp() {
 *   return (
 *     <Chatbot
 *       firebaseApp={firebaseApp}
 *       agentName="askRex"
 *       enableDynamicQuestions={true}
 *     />
 *   );
 * }
 * ```
 */
export function Chatbot(props: ChatbotConfig) {
  // Merge user config with defaults
  const config = useMemo(() => mergeWithDefaults(props), [props]);

  // Create ChatService instance
  const chatService = useMemo(() => {
    return new ChatService(config.firebaseApp, {
      useEmulators: config.useEmulators,
      projectId: config.projectId,
    });
  }, [config.firebaseApp, config.useEmulators, config.projectId]);

  // Create Firebase provider
  const provider = useMemo(() => {
    return new FirebaseChatProvider(chatService, {
      agentName: config.agentName,
      availableAgents: config.availableAgents,
      maxResults: config.maxResults,
      streamingThreshold: config.streamingThreshold,
    });
  }, [chatService, config.agentName, config.availableAgents, config.maxResults, config.streamingThreshold]);

  // Map our config to AIChatbot config
  const chatbotConfig: AIChatbotConfig = useMemo(() => ({
    enableStreaming: true,
    streamingThreshold: config.streamingThreshold,
    enableSources: true,
    enableQuestions: config.enableDynamicQuestions,
    enableTimingInfo: config.showTimingInfo,
    placeholder: config.placeholder,
    showAgentSwitcher: true,
    showTimingInfo: config.showTimingInfo,
    defaultAgent: config.agentName,
    maxInitialQuestions: config.maxDynamicQuestions,
    title: config.title,
    subtitle: config.subtitle,
  }), [
    config.streamingThreshold,
    config.enableDynamicQuestions,
    config.showTimingInfo,
    config.placeholder,
    config.agentName,
    config.maxDynamicQuestions,
    config.title,
    config.subtitle,
  ]);

  // Create callbacks
  const handleMessageSent = useMemo(() => {
    return (message: string) => {
      if (config.onMessageSent) {
        config.onMessageSent(message);
      }
    };
  }, [config.onMessageSent]);

  const handleMessageReceived = useMemo(() => {
    return (response: ChatResponse) => {
      if (config.onResponseReceived) {
        config.onResponseReceived(response.answer);
      }
    };
  }, [config.onResponseReceived]);

  return (
    <AIChatbot
      provider={provider}
      config={chatbotConfig}
      onMessageSent={handleMessageSent}
      onMessageReceived={handleMessageReceived}
      className={config.className}
      style={config.style}
    />
  );
}

// Re-export types for convenience
export type { ChatbotConfig };
export { ChatService } from './services/ChatService';
export type { ChatServiceInterface } from './services/ChatServiceInterface';
